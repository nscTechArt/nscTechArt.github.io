---
title: Chapter 5 Shading Basics
date: 2024-07-15 13:05 +0800
categories: [Graphics, Real Time Rendering]
media_subpath: /assets/img/Graphics/RealTimeRendering/
math: true
---

### 5.1 Shading Models

确定一个物体的外观表现，第一步是选出一个着色模型，它描述了物体的颜色会根据表面朝向、观察方向、光照等因素如何变化。

作为例子，我们将会使用Gooch着色模型的一个变体，这是一种非真实渲染的形式。Gooch模型背后的基本思路是，根据表面法线与光源方向进行着色：如果法线指向光源，则表面会呈现暖色调；如果法线指向光线方向，则表面呈现冷色调，介于二者之间的角度则会在这些色调之间插值。此外，我们会向模型添加风格化的高亮效果，最终的效果如下：

![](微信截图_20240715160346.png)

着色模型通常具有用于控制外观变化的多个属性，设置这些属性的值是确定物体外观表现的第二步。

和绝大多数着色模型一样，我们的示例模型将表面方向与观察方向、光线方向的相对关系作为影响着色效果的因素。通常，我们将这三种方向向量视为是归一化的。着色模型的定义如下：


$$
c_{shaded}=s\:c_{highlight}+(1-s)(t\:c_{warm}+(1-t)\:c_{cool})
$$


其中：


$$
\displaylines{c_{cool}=(0,0,0.55)+0.25\: c_{surface} ,\\
c_{warm}=(0.3,0,3,0)+0.25\: c_{surface} ,\\
c_{highlight}=(1,1,1), \\
t=\frac{(n \cdot l )+1}{2}, \\
r = 2 (n \cdot l) n - l,\\
s=(100(r\cdot v)-97)^{\mp}}
$$


我们应该对其中的一些数学运算较为熟悉了。

---

### 5.2 Light Sources

在我们刚才所使用的示例着色模型中，光线的影响很简单：为着色提供一个主导方向。当然，在现实世界中，光照是相当复杂的。现实中的有多种光源，每种光源都有自己的大小、形状、颜色、强度等属性。基于物理的真实感着色模型会将这些因素都考虑在内。而风格化着色模型使用光照的方式相对多样且灵活。

着色模型的下一步是判断物体表面是否会受到光照影响，而判断标准是与光源的距离、阴影、法线与光线方向的夹角是否大于90度等因素。但是，能够判断一点处是否有光照是一种二元性的结果，这对于大多数着色模型都是不能接受的。所以下一步的目标是能够表示出连续的光照强度，这可以通过简单插值实现。

我们将着色模型分为受光照部分和未受光照部分，并使用光照强度$k_{light}$对受光照部分线性缩放：


$$
c_{shaded}=f_{unlit}(n,v)+k_{light}f_{lit}(l,n,v)
$$


我们可以将光照强度$k_{light}$拓展为一个RGB的灯光颜色$c_{light}$：


$$
c_{shaded}=f_{unlit}(n,v)+c_{light}f_{lit}(l,n,v)
$$


如果有多个光源：


$$
c_{shaded}=f_{unlit}(n,v)+\sum_{i=1}^n c_{light}f_{lit}(l,n,v)
$$


非光照部分$f_{unlit}(n,v)$对应的是将着色模型中物体上没有受光照的部分，它可以有多种形式，取决于美术需求。比方说，可以是纯黑色，也可以像我们前面的Gooch模型那样呈现冷色调。通常来说，在现代着色模型中，这部分会通过间接光的形式计算出来，我们在后面会用专门的章节来讨论。

对于光照部分，我们前面提到过，如果光线方向与表面法线之间夹角大于90度时，表面上对应的位置就无法受到光源影响。而当夹角小于90度时，光线密度（也就是光照对于着色的贡献值）与二者之间的点积成正比。所以，在我们将光照与点积相乘之前，务必使用clamp确保点积结果不小于0，从而排除无法照射到表面的光线的影响。这样，我们就得到了一个兰伯特模型，即：


$$
c_{shaded}=f_{unlit}(n,v)+\sum_{i=1}^n (l_i\cdot n)^+ c_{light}f_{lit}(l,n,v)
$$


我们可以从公式中看出，光源通过两个参数来影响着色模型：光线方向$l$与光线颜色$c_{}light$。对于不同类型的光源来说，这两个参数在场景中的计算方式也不同。

接下来我们来讨论一些常见的光源，它们有一个共同点：给定一个表面位置，每个光源都仅仅会从一个方向$l$上照明该表面。也就是说，我们将会光源视为一个无限小的点。虽然严格来说这种假设与现实不符，但却是一个可以接受的近似。当然，也有例外，我们会在面光源中再展开讨论这种特殊情况。

#### 5.2.1 Directional Lights

平行光是最简单的光源模型。光线方向$l$与光线颜色$c_{}light$在整个场景中都是常量，除了$c_{}light$可能会因阴影而衰减。平行光没有位置这个概念。

#### 5.2.2 Punctual Lights

精准光源的是指面积无限小的、以固定的方向发射光线、且具有位置的光源，包含点光源与聚光灯两种形式。

对于punctual light来说，光线方向$l$需要通过光源位置与当前着色点位置计算得出：


$$
l=\frac{p_{light}-p_0}{||p_{light}-p_0||}
$$


这个等式是向量归一化一个不错的例子。大多数着色语言都内置了执行向量归一化的函数。但有些情况下，着色计算也会使用到归一化过程中的中间量，所以计算光线方向也可以通过下面这个步骤：


$$
\displaylines{d=p_{light}-p_0\\
r=\sqrt{d\cdot d}\\
l=\frac{d}{r}}
$$


##### Point Lights

向所有方向均匀发射光线的punctual light被称为点光源。对于点光源来说，光线密度和$c_{light}$与距离的平方反比成正比，即：


$$
c_{light}(r)=c_{light_0}(\frac{r_0}{r})^2
$$

其中，$c_{light_0}$是点光源在距离$r_0$处的光线颜色。我们将这个公式称为平方反比衰减。虽然这个公式在理论上是正确的，但是对于着色模型来说存在一些问题。

首先，当表面与光源距离很近时，$r$的值趋近于$0$，进而导致$c_{light}(r)$的值会快速增加，当$r$等于$0$时，又会得到一个无效的除法运算。为了解决这个问题，我们通常会在分母上增加一个较小的值$\epsilon$，即：


$$
c_{light}(r)=c_{light_0}\frac{r_0^2}{r^2+\epsilon}
$$


$\epsilon$的数值需要根据引擎的需求调整，比如虚幻引擎中该值等于$1$。

除了使用$\epsilon$，还有一种被CryEngine采用的方案是将$r$限制到一个最小值$r_{min}$：


$$
c_{light}(r)=c_{light_0}\Big(\frac{r_0}{max(r, r_{min})}\Big)^2
$$


不像$\epsilon$的选值有一定随机性，$r_{min}$的值在物理上是有意义的，也就是发光物体的半径。

平方反比的衰减还有另一个问题，也就是当表面与光源的相对距离较远时，会带来一定的性能问题。光线强度会随着距离不断减小，但根据公式计算的话，永远不会减小到$0$，只是无限趋近与$0$。但在我们的渲染问题上，光线强度应该在某个有限距离上降低到$0$。想要实现这种效果有很多方法，但是为了能够避免光线强度的突然截断，我们优先选择让函数的导数与函数值在相同的距离上同时为$0$的方法。一种思路是将平方反比等式与特定属性的*windowing function*相乘。例如在虚幻引擎与寒霜引擎中，使用的windowing function为：


$$
f_{win}(r)=\Big( 1-\big( \frac{r}{r_{max}} \big)^4 \Big)^{+2}
$$


其中$+2$表示当值小于零时，在平方之前会将值限制在$0$。下图展示了使用windowing function对平方反比函数的校正效果

![](微信截图_20240716095345.png)

引擎的需求会影响 windowing function的选择。比方说，如果函数在相对较低的空间频率上采样（比如light  map或逐顶点光照）时，让函数的导数在$r_{max}$上等于$0$尤为重要。例如CryEngine没有光照贴图与顶点照明，所以它采用了更简单的矫正方式，在距离为$[0.8r_{max},r_{max}]$的范围上线性衰减。

还有一些引擎，没有将符合平方反比定律作为首要的要求，所以会采用完全不同的计算方式。首先，我们可以将计算点光源光照的公式写成一般的形式，即：


$$
c_{light}(r)=c_{light_0}f_{dist}(r)
$$


其中$f_{dist}(r)$是关于距离的函数，这种函数被称为距离衰减函数。例如在虚幻引擎中，有两种光照衰减的模型，一种是我们前面所提到的平方反比模型，而另一种则采用可以由开发者通过工具进行调节的指数衰减。

##### Spot Lights

在现实世界中，几乎所有的光源的光照会同时收到距离与方向的影响，而不像点光源那样只需考虑距离。我们可以使用函数$f_{dir}(l)$来表示方向性相关的衰减，并和距离函数函数一起影响光照在空间中的作用，即：


$$
c_{light}(r)=c_{light_0}f_{dist}(r)f_{dir}(l)
$$


使用不同的$f_{dir}(l)$会带来不同的光照效果，其中一种重要的类型是聚光灯。我们将聚光灯的方向向量表示为$s$，则衰减函数会相对$s$成旋转对称，基于这个性质，我们需要将$s$与反向的光线方向$-l$之间的夹角$\theta_s$作为一个重要参数。这里之所以使用反向的光线方向，是因为我们将$l$定义为由表面指向光源，而这里我们需要一个从光源指向表面的向量。

绝大多数聚光灯函数会使用包含$\theta_s$余弦值的表达式，这在与角度相关的着色计算中很常见。此外，聚光灯通常还有一个本影角$\theta_u$，它定义了聚光灯的最大角度范围，也就是说当$\theta_s \ge \theta_u$时，$f_{dir}(l)=0$。与此对应的是半影角$\theta_p$，用于定义一个聚光灯内部的圆锥，该圆锥内的光照强度不会因为光线方向衰减。

![](微信截图_20240716102218.png)

大部分聚光灯所使用的方向衰减函数都比较相近，我们以寒霜引擎为例：


$$
\displaylines{t=\Big( \frac{cos\theta_s-cos\theta_u}{cos\theta_p - cos\theta_s} \Big)^{\mp},\\
f_{dir}(l)=t^2}
$$


#### 5.2.3 Other Light Types

之前讨论的光源类型都是抽象的。在现实中，光源是有大小和形状的，它们从多个方向照射表面点。在渲染中，这种光源称为区域光源（area lights），它们在实时应用中的使用逐渐增加。

区域光源的渲染技术分为两类：

1. 模拟阴影边缘柔化的技术，这是由于区域光源被部分遮挡所致（参见第7.1.2节）。
2. 模拟区域光源对表面着色影响的技术（参见第10.1节）。

这种第二类光照在光滑的镜面反射表面上最为显著，在这种表面上可以清晰地辨别光源的形状和大小。尽管定向光和点光源不太可能被废弃，但它们不再像过去那样普遍。为了考虑光源面积的近似方法已经被开发出来，这些方法相对廉价且易于实现，因此被广泛使用。GPU性能的提升也使得可以实现比过去更复杂的技术。

---

### 5.3 Implementing Shading Models

我们将在这一小节介绍设计与编写着色模型时一些关键的细节。

#### 5.3.1 Frequency of Evaluation

当设计着色实现时，我们需要根据计算频率对计算步骤进行一定的划分。首先，确定给定的计算的结果是否在整个draw call期间都始终是一个常量，如果是的话，则该计算可以有CPU执行，计算结果通过uniform shader input传递给图形API。

#### 5.3.2 Implementation Example

现在我们来展示一个示例的着色模型的实现。
