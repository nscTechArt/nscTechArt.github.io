---
title: Type Conversion, Type Aliases, and Type Deduction
date: 2024-07-08 10:22 +0800
categories: [Codes, Learn C++]
---

### 10.1 Implicit type conversion

#### Introduction to type conversion

对象的值以连续比特的形式存储，这些连续的比特会由对象的数据类型告诉编译器要如何解释为有意义的数值。不同的数据类型可能会表示相同的值，比方说，整数值`3`可能会被存储为`0000 0000 0000 0000 0000 0000 0000 0011`，而浮点数3.0则可能会被存储为`0100 0000 0100 0000 0000 0000 0000 0000`

所以，如果我们编译下面这行代码，会发生什么？

```c++
float f { 3 };
```

编译器不能直接把代表`int`值`3`的bit拷贝到为`float`类型`f`而分配的内存中。实际上，编译器需要将整数值`3`转换为同等的、可以被存储到为`f`分配的内存中的浮点数值`3.0`。

我们将从一个不同类型的数值中创建一个新的特定类型的数值的过程称为**转换conversion**

> 转换不会改变被转换的值或类型。相反，转换的结果是创建一个具有所需类型的新值。
{: .prompt-info}

类型转换可以通过两种方式触发，分别是显式和隐式。我们先来了解隐式类型转换

#### Implicit type conversion

隐式类型转换又被称为自动类型转换。当我们需要一种特定类型的值，却被提供了另一种类型的值时，编译器会自动执行隐式类型转换。C++中的绝大多数类型转换都是隐式的。我们来看一些例子：

初始化或赋值

```c++
double d {3}; // int -> double
d = 6; // int -> double
```

函数返回值


```c++
float doSometing()
{
	return 3.0; // double -> float
}
```

二元操作符

```c++
double division {4.0 / 3} // int value 3 -> double
```

if语句中的非布尔值

```c++
if(5) {} // int -> bool
```

形参与实参

```c++
void doSomething(long l) {}

doSomething(3); // int -> long
```

#### What happens when a type conversion is invoked

当类型转换被触发时，编译器会判断是否可以从当前值的类型转换为所需类型。如果可以，则编译器会创建所需类型的值。如果编译器无法找到可行的转换，则编译器会fail并报错。类型转换失败的原因有很多。比如说，编译器不知道如何在原始类型和所需类型之间完成值的转换：

```c++
int x {3.5}; // brace-intialization不允许会导致数据丢失的转换
```

也有可能编译器会无法确定哪种可能的类型转换是明确的最佳选择，我们会在博客中深入讨论。
