---
title: Compound Types References and Pointers
date: 2024-07-10 09:55 +0800
categories: [Codes, Learn C++]
---

随着我们开发的程序越来越复杂，C++中的基础类型已经逐渐无法实现一些复杂的需求。我们来看一个例子。

假设我们想实现一个数学程序，用于计算两个分数。那么我们应该如果通过代码来表示分数呢？可能会想要通过一对int值来实现，例如：

```c++
#include <iostream>

int main()
{
    // first fraction
    int num1 {};
    int den1 {};

    // second fraction
    int num2 {};
    int den2 {};

    // used to remove the slash between the numerator and denominator
    char ignore {};

    std::cout << "Enter a fraction: ";
    std::cin >> num1 >> ignore >> den1;

    std::cout << "Enter a fraction: ";
    std::cin >> num2 >> ignore >> den2;

    std::cout << "The two fractions multiplied: " << num1 * num2 << '/' << den1 * den2 << '\n';
}
```

虽然这个程序可以运行，但是仍存在一些问题。首先，每对整数之间的联系相对松散——除了注释和它们在代码中的使用上下文外，很难看出每对分子和分母是相关的。其次，按照DRY（不要重复自己）原则，我们应该创建一个函数来处理用户输入的分数（并包含一些错误处理）。然而，函数只能返回一个值，那么我们如何将分子和分母返回给调用者呢？

显然，基础类型已经不能满足我们的需求了

#### 12.1.1 Compound data types

在C++中，复合类型是通过其他复合类型与基础类型构造而来的。每个复合类型都有其自己独特的属性。

C++支持以下复合类型：

- 函数
- 数组
- 指针类型
  - 函数指针
  - 对象指针
- 成员类型的指针
  - 数据成员的指针
  - 函数成员的指针
- 引用类型
  - 左值引用
  - 右值引用
- 枚举类型
  - 无范围的枚举
  - 有范围的枚举
- class类型
  - 结构体
  - class
  - union

我们对于函数这个复合类型已经比较熟悉了，例如：

```c++
void doSomething(int x, double y) {}
```

这个函数的类型是`void(int, double)`

本篇博客中，我们将逐一介绍上述的这些复合类型。

### 12.2 Value categories (lvalues and rvalues)

我们知道，C++中的表达式有三种作用：

- 计算得出一个单一值
- 产生side effects
- 计算得到对象或函数

前两点我们已经比较熟悉了，而要理解第三点，我们需要首先清楚C++中的表达式都有两个属性：**类型**type与**值类别**value category。我们分别展开讨论一下。

#### 12.2.1 The type of an expression

表达式的类型等同于表达式经过计算得到的值、对象或函数的类型。我们可以看下面两个表达式：

```c++
int main()
{
    auto v1 {12 / 4};   // type of expression => int
    auto v2 {12.0 / 4}; // type of expression => double
}
```

编译器可以根据表达式的类型判断在给定的上下文中，表达式是否有效，例如：

```c++
#include <iostream>

void print(int x)
{
    std::cout << x << '\n';
}

int main()
{
    print("foo"); 
    // error: print() was expecting an int argument, 
    // we tried to pass in a string literal
}
```

需要注意的是，表达式类型必须在需要在编译时确定，而表达式的值既可以在编译时确定(constexpr），也可以在运行时确定（非constexpr）

#### 12.2.2 The value category of an expression

我们看下面这个程序：

```c++
int main()
{
    int x{};

    x = 5; // valid: we can assign 5 to x
    5 = x; // error: can not assign value of x to literal value 5
}
```

其中，第一个赋值语句是有效的，而另一个赋值语句却会触发编译器报错。那么编译器是如何知道哪些表达式可以赋值语句中任意一侧被有效地使用呢？

答案是表达式的值类别属性，它表示了表达式的求职结果与生命周期的特性。在C++11之前，只有两种值类别：`lvalue`与`rvalue`。C++11引入了三个额外的值类型：`glvalue`，`prvalue`，`xvalue`，从而可以支持一个名为`move semantic`的新特性。

我们暂时只先讨论左值和右值。其余的值类型将在以后的相关博客中讨论。

#### 12.2.3 Lvalue and rvalue expressions

左值是指可以取地址的表达式，即存储在某个内存未知，可以持久存在。例如

```c++
int x = 10;
int& ref = x; // x is a lvalue
```

同时，由于常量的存在，左值还可以被细分为可修改的左值以及不可修改的左值（即左值是`const`或`constexpr`）。

而右值指的是不能取地址的临时值，通常作为表达式的结果，不能长久存在。例如：

```c++
int y = x + 5; // (x + 5) is a rvalue
```

> 左值表达式求值为一个可识别的对象。而右值求职为一个值。
{: .prompt-info}

现在我们可以回答前面关于赋值语句的问题了。赋值运算符`=`要求左侧的运算数是可修改的左值表达式，而右侧的运算数需要四号一个右值表达式。

#### 12.2.4 Lvalue to rvalue conversion

当我们表达式需要一个右值，而我们提供了一个左值时，左值会隐式地转换为右值。例如：

```c++
int main()
{
	int x {1};
    int y {2};
    
    x = y;
}
```

### 12.3 Lvalue references

在C++中，引用是对已有对象的别名。一旦定义了引用，对引用的任何操作都将应用于被引用的对象。

> 引用本质上与被引用的对象相同
{: .prompt-info}

现代C++中包含了两种引用，左值引用和右值引用。我们先来讨论一些左值引用。

#### 12.3.1 Lvalue reference types

左值引用（通常被简称为引用）充当现有左值（例如变量）的别名。想要声明一个左值变量类型，我们在类型声明中使用`&`，也就是：

```c++
int      // a normal int type
int&     // an lvalue reference to an int object
double&  // an lvalue reference to a double object
```

#### 12.3.2 Lvalue reference variables

通过左值引用类型，我们可以创建一个左值引用变量：

```c++
#include <iostream>

int main()
{
    int x { 5 };    // x is a normal integer variable
    int& ref { x }; // ref is an lvalue reference variable that can now be used as an alias for variable x

    std::cout << x << '\n';  // print the value of x (5)
    std::cout << ref << '\n'; // print the value of x via ref (5)
}
```

#### 12.3.3 Modifying values through an lvalue reference

通过引用，我们不仅可以读取被引用对象的值，也可以修改被引用对象的值，例如：

```c++
#include <iostream>

int main()
{
    int x { 5 }; // normal integer variable
    int& ref { x }; // ref is now an alias for variable x

    std::cout << x << ref << '\n'; // print 55

    x = 6; // x now has value 6

    std::cout << x << ref << '\n'; // prints 66

    ref = 7; // the object being referenced (x) now has value 7

    std::cout << x << ref << '\n'; // prints 77
}
```

#### 12.3.4 Initialization of lvalue references

与常量一样，所有的引用在声明的时候必须进行初始化。当引用被一个对象（或函数）初始化时，我们说它被绑定到那个对象（或函数）。这种引用绑定的过程被称为引用绑定。被引用的对象（或函数）有时被称为被引用体

引用必须绑定给一个可修改的左值，绑定给不能修改的左值或右值将会导致编译报错，例如：

```c++
int main()
{
    int x { 5 };
    int& ref { x }; // valid: lvalue reference bound to a modifiable lvalue

    const int y { 5 };
    int& invalidRef { y };  // invalid: can't bind to a non-modifiable lvalue
    int& invalidRef2 { 0 }; // invalid: can't bind to an rvalue

    return 0;
}
```

大多数情况下，引用的类型需要与引用体的类型匹配（也有例外，我们会在继承的相关内容中讲到）：

```c++
int main()
{
    int x { 5 };
    int& ref { x }; // okay: reference to int is bound to int variable

    double y { 6.0 };
    int& invalidRef { y }; // invalid; reference to int cannot bind to double variable
    double& invalidRef2 { x }; // invalid: reference to double cannot bind to int variable
}
```

另外，左值引用的引用体也不能是`void`（有什么意义呢？）

#### 12.3.5 Reference cannot be reseated(change to refer to another object)

一旦初始化后，引用就不能被重新绑定给其他对象了。我们考虑下面这个程序：

```c++
#include <iostream>

int main()
{
    int x {5};
    int y {6};

    int& ref {x}; // now ref is an alias for x

    ref = y; // assigns 6 (the value of y) to x

    std::cout << x << '\n';
}
```

在这个实例中，因为`ref`已经被绑定给`x`，所以`ref = y`并不能将`ref`设置为`y`的引用，而是会用`y`的值来修改`x`

#### 12.3.6 Lvalue reference scope and duration

引用变量遵循与普通变量相同的作用域和生命周期规则：

```c++
#include <iostream>

int main()
{
    int x { 5 }; // normal integer
    int& ref { x }; // reference to variable value

     return 0;
} // x and ref die here
```

#### 12.3.7 References and referents have independent lifetims

有一个例外，引用的生命周期与对应引用体的生命周期是无关的。换句话说，下面两种说法都是正确的：

- 一个引用可以在被引用对象销毁之前被销毁
- 被引用的对象可以在引用销毁之前被销毁

当引用被提前销毁时，引用体不会收到任何影响，例如：

```c++
#include <iostream>

int main()
{
    int x { 5 };

    {
        int& ref { x };   // ref is a reference to x
        std::cout << ref << '\n'; // prints value of ref (5)
    } // ref is destroyed here -- x is unaware of this

    std::cout << x << '\n'; // prints value of x (5)
} // x destroyed here
```

#### 12.3.8 Dangling references

当被引用的对象在引用它的引用之前被销毁时，该引用就会指向一个不再存在的对象。这样的引用称为悬空引用。访问悬空引用会导致未定义行为。

#### 12.3.9 References aren't objects

在C++中，引用并非对象，它不需要存在或占用内存空间。如果可能的话，编译器会通过将引用的所有出现替换为被引用体来优化引用。但这种做法也并非总是可行的，此时引用可能会需要存储空间。

由于引用不是对象，它们不能在需要对象的地方使用（例如，不能有引用的引用，因为左值引用必须引用一个可识别的对象）。

### 12.4 Lvalue reference to const

现在我们知道，一个左值引用只能绑定到一个可修改的左值上。所以下面这个程序会编译错误：

```c++
const int x {5};
int& ref {x}; // error: ref cannot bind to non-modifiable lvalue
```

但是如果我们需要为一个const变量创建引用，要怎么办呢？

#### 12.4.1 Lvalue reference to const

当声明一个引用时，使用const关键字就可以将引用与一个不可修改的左值绑定，例如

```c++
const int x {5};
const int& ref {x};
```

对于const引用来说，只能访问引用体的值，而不能通过引用修改（因为其本身就不能被修改）

#### 12.4.2 Initializing an lvalue reference to const with a modifiable lvalue

常量左值引用也可以绑定到可修改的左值上。这种情况下，当我们通过引用访问引用体时，引用体将会被视为const，但引用体本身仍然是可修改的。例如：

```c++
#include <iostream>

int main()
{
    int x { 5 };          // x is a modifiable lvalue
    const int& ref { x }; // okay: we can bind a const reference to a modifiable lvalue

    std::cout << ref << '\n'; // okay: we can access the object through our const reference
    ref = 7;                  // error: we can not modify an object through a const reference

    x = 6;                // okay: x is a modifiable lvalue, we can still modify it through the original identifier
}
```

> 除非我们需要修改被引用对象的值，我们要优先使用常量左值引用
{: .prompt-info}

#### 12.4.3 Initializing an lvalue reference to const with an rvalue

我们知道，左值引用不能绑定到右值上，只能绑定给可修改的左值。然而常量左值引用却可以：

```c++
const int& ref {5};
std::cout << ref << '\n'; // prints 5
```

在这种情况下，编译器会创建一个临时变量，并用右值对该临时变量进行初始化，而常量左值引用也会绑定到这个临时变量上。

#### 12.4.4 Initializing an lvalue reference to const with a value of a different type

常量左值引用甚至可以绑定到其他类型的对象上，只要这些值可以被隐式转换到引用类型上。例如：

```c++
char c {'a'};
const int& r2 {c};
std::cout << r2 << '\n'; // prints 97
```

### 12.5 Pass by lvalue reference

